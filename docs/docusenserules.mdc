# Cursor Rules for Docusense OCR Prototype

## üéØ Project Context

**Docusense OCR Prototype** - A comprehensive local-first OCR service with extended functionality. The technology stack includes Python, Flask with API blueprints, Tesseract OCR with multi-language support, core file processing libraries (Pillow, pdf2image, python-docx, pandas, openpyxl), simple REST API endpoints, and an enhanced HTML/CSS/JavaScript frontend with advanced settings.

## ‚úÖ Core Development Principles

### 1. Always Follow These Rules
- **MUST** keep the implementation simple and efficient, directly following the `Implementation Plan_ Docusense Prototype.md`.
- **MUST NOT** add any features, dependencies, or architectural complexity not specified in the updated implementation plan (Phases 1-7). This remains a prototype with extended functionality.
- **MUST** ensure the application is always runnable and free of errors across all supported file formats and API endpoints.
- **MUST** run all Python commands from the project root directory.
- **MUST** thoroughly validate each code change to ensure it works as expected and causes no regressions, especially across the 6 core supported file formats. Superficial checks are not sufficient.
- **MUST** maintain a pylint score of 10.0/10.0 for `app.py`. No errors are acceptable despite the increased complexity.
- **MUST** add clear and concise comments to each logical block of code for better readability and debugging, particularly for OCR parameter handling and multi-page PDF processing.
- **MUST NOT** use hardcoded values (e.g., strings, paths, numbers, DPI settings). All such constants **MUST** be managed in the central `config.py` file.
- **MUST** keep all features POC-focused, running locally without external services, including the REST API authentication.
- **MUST** update the documentation only when functionality changes. Keep it minimal and essential despite the expanded feature set.
- **MUST** avoid hallucinations by verifying all library usage against official documentation, especially for new dependencies (pandas, openpyxl).

### 2. Anti-Over-Engineering Guidelines
- **PROTOTYPE FIRST**: The goal is a working proof-of-concept, not a production-ready application.
- **NO ABSTRACTIONS**: Avoid creating complex abstractions, classes, or design patterns unless absolutely necessary for basic functionality. A single-file Flask app is the goal.
- **STICK TO THE PLAN**: Only implement features detailed in the updated `Implementation Plan_ Docusense Prototype.md` (Phases 1-7). Do not add "nice-to-have" features beyond the specified extended functionality.
- **MANAGED DEPENDENCIES**: Only use Python libraries specified in the updated `requirements.txt` for core file format support (PDF, CSV, Excel), advanced OCR settings, and simple API functionality. Each new dependency must serve the core prototype goals.
- **CENTRALIZED CONFIGURATION**: Use the single `config.py` file for all constants, paths, settings, DPI presets, and language configurations. Despite the increased complexity, avoid complex configuration setups.

### 3. Code Quality Standards
- **Python**: Follow PEP 8. Use specific exception handling (e.g., `FileNotFoundError`, not a generic `Exception`).
- **JavaScript**: Use modern ES6+ features and proper error handling for `fetch` calls.
- **Pylint**: The `app.py` file **MUST** achieve a 10.0/10.0 score with **ZERO** errors.
- **Linting Process**: After any change to `app.py`, run `pylint app.py --score=y` and fix all reported issues immediately.
- **Documentation**: Each logical block of code **MUST** be preceded by a comment explaining its purpose. This is for better referencing and debugging.

## üîß Systematic Development Approach

### 4. Feature Implementation Process
**ALWAYS use this step-by-step systematic approach for implementing new features:**

1. **Analysis Phase**
   - [ ] Read and understand the feature requirements from the Implementation Plan
   - [ ] Identify all affected files and components
   - [ ] Review existing codebase for similar patterns or dependencies
   - [ ] Plan the implementation approach with minimal complexity

2. **Design Phase**
   - [ ] Design the simplest possible solution that meets requirements
   - [ ] Identify configuration values that need to be added to `config.py`
   - [ ] Plan the code structure and flow
   - [ ] Consider error handling requirements

3. **Implementation Phase**
   - [ ] Create/update configuration values in `config.py` first
   - [ ] Implement core functionality with proper comments
   - [ ] Add specific exception handling (no generic `Exception` blocks)
   - [ ] Ensure pylint compliance throughout development

4. **Validation Phase**
   - [ ] Test the new feature thoroughly through manual testing
   - [ ] Verify no regressions in existing functionality
   - [ ] Confirm pylint score remains 10.0/10.0
   - [ ] Update documentation if functionality changes

### 5. Issue Resolution Process
**When tag "Issue: " is used, ALWAYS follow this systematic approach:**

#### 5.1 Issue Analysis Phase
1. **Problem Identification**
   - [ ] Reproduce the issue in the current environment
   - [ ] Document exact error messages, stack traces, or unexpected behavior
   - [ ] Identify the specific components/files involved

2. **Root Cause Analysis**
   - [ ] Examine the relevant code sections thoroughly
   - [ ] Check for recent changes that might have introduced the issue
   - [ ] Review configuration values and dependencies
   - [ ] Analyze error logs and diagnostic information
   - [ ] Identify the underlying cause (not just symptoms)

3. **Impact Assessment**
   - [ ] Determine what functionality is affected
   - [ ] Assess potential side effects of different fix approaches
   - [ ] Prioritize the fix based on severity and impact

#### 5.2 Solution Design Phase
4. **Fix Strategy Development**
   - [ ] Design the minimal fix that addresses the root cause
   - [ ] Consider alternative approaches and their trade-offs
   - [ ] Ensure the fix aligns with prototype principles (simplicity first)
   - [ ] Plan for proper error handling and edge cases

#### 5.3 Implementation Phase
5. **Fix Implementation**
   - [ ] Implement the fix using the systematic approach
   - [ ] Add/update configuration values in `config.py` if needed
   - [ ] Include clear comments explaining the fix
   - [ ] Maintain pylint compliance

#### 5.4 Verification Phase
6. **Fix Validation**
   - [ ] Verify the original issue is completely resolved
   - [ ] Test edge cases and potential regression scenarios
   - [ ] Confirm no new issues are introduced
   - [ ] Validate pylint score remains 10.0/10.0
   - [ ] Document the fix in commit messages or relevant documentation

## ‚öôÔ∏è Configuration Management
- **NO HARDCODED VALUES**: All constants, paths, and configuration values **MUST** be defined in a central `config.py` file.
- **USE VARIABLES**: Import variables from `config.py` instead of using hardcoded strings or numbers in the application code.
- **SIMPLICITY**: Keep the `config.py` simple. It should only contain variable assignments.

## üìö Document Maintenance
- **MAINTAIN**: Keep the `README.md` and documents in the `docs/` folder consistent with the current state of the prototype.
- **ESSENTIAL ONLY**: Do not create new documentation files. The existing set is sufficient for the prototype.

## üöÄ Quick Development Commands

### Environment Setup
```powershell
# Activate virtual environment
.\venv\Scripts\Activate.ps1

# Install/update dependencies
pip install -r requirements.txt
```

### ‚ö†Ô∏è CRITICAL: Working Directory Requirements
**The Flask backend MUST be run from the project root directory:**
```powershell
# ‚úÖ CORRECT: Always run from project root
python app.py

# ‚ùå INCORRECT: Running from subdirectories will likely fail
cd src
python app.py  # This will fail if paths are relative to the root
```

### Development Workflow
```powershell
# 1. Activate the virtual environment
.\venv\Scripts\Activate.ps1

# 2. Start the development server
python app.py

# 3. Make code changes in app.py or templates/index.html
#    (The Flask server will auto-reload on backend changes)

# 4. Manually test the changes in the browser at http://127.0.0.1:5000

# 5. Before committing, check code quality
pylint app.py --score=y
```

### Manual Testing
- Open `http://127.0.0.1:5000` in your browser.
- Test the file upload with all 6 supported file types as detailed in `docs/Testing_Guide.md`.
- Verify advanced OCR settings (DPI, language, engine parameters) function correctly.
- Test enhanced PDF processing with multi-page documents.
- Test spreadsheet processing with CSV and Excel files.
- Test the REST API endpoints using the `/api-test` interface or external tools (no authentication required).
- Verify OCR output, image previews, canvas overlays, and JSON download functionality.

## üîß API Reference

### **Web Interface Routes**
- `GET /`: Serves the enhanced `index.html` frontend with advanced OCR settings.
- `POST /upload`: Handles file uploads from web form, performs OCR with configurable parameters, and returns structured JSON data.
- `GET /uploads/<filename>`: Serves uploaded or processed image files to be displayed on the frontend.

### **REST API Endpoints (`/api/v1/`)**
- `POST /api/v1/ocr`: Programmatic file upload and OCR processing with all advanced settings.
- `GET /api/v1/formats`: Returns list of all supported file extensions (6 core formats).
- `GET /api/v1/languages`: Returns available Tesseract language packs for multi-language OCR.
- `GET /api/v1/health`: Basic service health check with version status.
- `GET /api/v1/docs`: Basic API documentation in JSON format.
- `GET /api-test`: Interactive API testing interface for all endpoints.

### **Simple API Access**
- **No Authentication**: All API endpoints are accessible without API keys for prototype usage.
- **Standard HTTP**: Simple REST endpoints with standard HTTP status codes.
- **Error Responses**: Standardized JSON error format with appropriate HTTP status codes.

## üîê Security Guidelines
- **LOCAL USE ONLY**: This is an extended prototype and is not secure for production use.
- **DO NOT** expose the development server to the internet.
- **No Authentication**: API endpoints are openly accessible for prototype testing and development purposes.
- The application includes minimal security hardening and lacks production-grade security (input sanitization, CSRF protection, authentication).

## üìã Simplified Checklist for Changes

### Before Committing Code
- [ ] Does the new code directly contribute to a task in the extended `Project_TODO_List.md` (Phases 1-7)?
- [ ] Is the implementation as simple as possible despite the increased functionality?
- [ ] Has the change been thoroughly validated across all affected file formats and API endpoints?
- [ ] Does `app.py` still have a 10.0/10.0 pylint score with zero errors despite the added complexity?
- [ ] Is the code free of generic `except Exception:` blocks, especially for new file format processors?
- [ ] Are new code blocks and functions properly documented with comments, particularly OCR parameter handling?
- [ ] Are all new constants (DPI settings, language codes, file extensions) properly defined in `config.py`?
- [ ] Does the enhanced UI remain clean and functional with the advanced settings?
- [ ] Do all API endpoints follow consistent JSON response formats and error handling (no authentication required)?
- [ ] Have you tested enhanced PDF processing with multi-page documents?
- [ ] Have you tested spreadsheet processing with CSV and Excel files?
- [ ] Have you tested both web interface and simple API functionality for any changes?
- [ ] Have you followed the systematic approach for feature implementation or issue resolution?

---

**These rules ensure the Docusense OCR Prototype with extended functionality is developed efficiently, maintaining focus on essential features (6 core file formats, enhanced PDF processing, spreadsheet support, advanced OCR settings, simple REST API) without unnecessary complexity, while preserving systematic approaches for quality and reliability across the expanded feature set.**